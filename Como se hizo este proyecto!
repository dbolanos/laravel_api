Como se hizo este proyecto!

Bueno lo primero fue intslar php y apache y maariadb luego instalar composer para descargar laravel, en este caso voy a usar laravel 5.5, podemos utilizar el comando php artisan --version para saber la version de laravel.

Lo primero que hay que hacer cuando se descargar un laravel es ir nos al proyecto abrir una consola y digitar:
	composer install

el siguiente comando seria:
	Nota: Este comando se puede correr siempre y cuando y el archivo de .env exista
	php artisan key:generate

y si tenemos seeders seria correr.. los sederse
	php artisan migrate --seed

ahora algunas veces tendremos que aplicar el sigueinte comando para que composer vuelva a refrescar todo

	composer dumpautoload

Para crear un model utilizamos el siguiente comando el cual nose creara una plantilla por default

	php artisan make:model Fabricante


Migrations

    Las Migrations (desplazamientos o migraciones) son un tipo de control de versiones pero para bases de datos.
    Nos permiten modificar el esquema de la base de datos y estar actualizados correctamente del estado del mismo. Es decir con las migrations podremos crear el esquema de tablas, cubrir datos en la tablas, hacer rollback para volver a estados iniciales, etc...
    Las migrations en Laravel se encuentran en la carpeta database/migrations.
    Para cada tabla de la base de datos tendremos 1 archivo de migrations.
    A la hora de ejecutar las migrations Laravel ejecuta los archivos de migration que están en la carpeta database/migrations.

Pasos a seguir para crear las plantillas de Migrations para cada tabla

    Primero tenemos que crear una base de datos, usuario y contraseña con PHPMyAdmin, ya que PHP Artisan no puede hacer esa tarea por nosotros.
    Configuraremos los parámetros de conexión a nuestra base de datos en el fichero .env que se encuentra en la ruta raíz de Laravel.

Por ejemplo podemos crear la siguiente base de datos, crear un usuario y la contraseña

y luego lo configuremos en el archivo .env

	DB_CONNECTION=mysql
	DB_HOST=127.0.0.1
	DB_PORT=3306
	DB_DATABASE=laravel_api
	DB_USERNAME=root
	DB_PASSWORD=123456

Una vez configurada la conexión a la base de datos procederemos a crear una plantilla de Migration para cada tabla.
ATENCIÓN: si hemos creado las plantillas de Modelo sin usar PHP Artisan, entonces borrarremos todas las migrations que aparecen por defecto en la carpeta database/migrations. En otro caso borraremos solamente las migrations que no tengan que ver con nuestras tablas.
Si necesitamos crear las plantillas de Migrations para nuestras tablas por que hemos borrado todos los ficheros podemos ejecutar el siguiente 
comando para cada una de las tablas:

	# Crearemos primero la plantilla de migration para Fabricantes ya que Aviones tiene una relación que depende de Fabricantes.
	php artisan make:migration fabricantes_migration --create=fabricantes

	# A continuación la plantilla de migration para aviones.
	php artisan make:migration aviones_migration --create=aviones

Ejemplo de la migracion:

	<?php

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class AvionesMigration extends Migration {

	/**
	 * Run the migrations.
	 *
	 * @return void
	 */
	public function up()
	{
		Schema::create('aviones', function(Blueprint $table)
		{
			$table->increments('serie');
			$table->string('modelo');
			$table->float('longitud');
			$table->integer('capacidad');
			$table->integer('velocidad');
			$table->integer('alcance');
			
			// Añadimos la clave foránea con Fabricante. fabricante_id
			// Acordarse de añadir al array protected $fillable del fichero de modelo "Avion.php" la nueva columna:
			// protected $fillable = array('modelo','longitud','capacidad','velocidad','alcance','fabricante_id');
			$table->integer('fabricante_id')->unsigned();

			// Indicamos cual es la clave foránea de esta tabla:
			$table->foreign('fabricante_id')->references('id')->on('fabricantes');

			// Para que también cree automáticamente los campos timestamps (created_at, updated_at)
			$table->timestamps();
		});
	}

	/**
	 * Reverse the migrations.
	 *
	 * @return void
	 */
	public function down()
	{
		Schema::drop('aviones');
	}

}



 ATENCIÓN:: En XAMPP para que funcione correctamente PDO MySQL que es el sistema de acceso a base de datos que viene por defecto en XAMPP, hay que habilitar dicha extensión editando el fichero C:\xampp\php\php.ini y sacando el ; inicial en la línea extension=php_pdo_mysql.dll. Si no lo hacemos al intentar ejecutar las migraciones obtendremos un error del estilo: [PDOException] could not find driver en Laravel. Acordarse de Reiniciar Apache en XAMPP una vez hecho el cambio.
PHP Artisan lleva el control de las Migrations a través de una tabla llamada migrations que tendríamos que tener en el MySQL. Para instalar esa tabla de forma automática antes de poder ejecutar las Migrations tenemos que ejecutar el siguiente comando (1 vez solamente por proyecto):

# Esta línea ya no es necesaria por que lo hace automáticamente en las últimas versiones de Laravel.
php artisan migrate:install
# Migration table created successfully



Ejecutamos a continuación todas las migrations para que cree las tablas en el MySQL:

php artisan migrate

#Migrated: 2015_04_09_105558_fabricantes_migration
#Migrated: 2015_04_09_105827_aviones_migration

# Si vamos a PHPMyAdmin veremos que ha aparecido una nueva tabla llamada migrations.

# Si queremos volver a poner la base de datos en su estado inicial podemos hacerlo con:
php artisan migrate:refresh


Si cuando corremos el comando de php artisan migrate nos da el siguiente error:

[Illuminate\Database\QueryException]
SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes (SQL: alter table `users` add unique `users_email_unique`(`email`))
 
[PDOException]
SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 767 bytes

entonces podemos hacer lo siguiente:

1) Cambiar nuestra configuracion en el archivo de databases.php para que funciones con utf8
2) Cambiar la configuracion de nuestra base de datos para que trabaje con utf8mb4

En este caso... usare la opcion 1 

In case you don’t want to use the utf8mb4 (that is now setup by default in Laravel 5.4) – instead you want to stick with utf8 that was in use in Laravel 5.3 and all versions before, simply edit /config/database.php  and find these two lines in mysql driver:

	'charset' => 'utf8mb4',
	'collation' => 'utf8mb4_unicode_ci',

and replace them with with

	'charset' => 'utf8',
	'collation' => 'utf8_unicode_ci',

That will stop using the utf8mb4 and will change back to utf8. The good thing about this is that you’ll be able to fit 25% more characters into the same columns in database compared with utf8mb4 and that you’ll be able to use existing databases and projects without the need of converting them if you don’t want to. And the downside is that some characters will not be able to be saved to database like this mac command character ⌘ or some emojis. Utf8 can only store Plane Unicode while utf8mb4 can store any unicode character.  Utf8mb4 is also 100% backwards compatible with utf8.

Esta informacion la tome de http://geektnt.com/2017/01
Ahi tambien explica otras maneras de resolver el problema.



Población automática de las tablas de la base de datos con Laravel y PHP Artisan

    Con PHP Artisan podremos llenar de forma masiva las tablas con datos de ejemplo, utilizando lo que se conoce como Seeders.
    Los Seeders son una serie de instruciones en las cuales indicamos cómo queremos que se llenen las tablas con datos.
    Los Seeders se encuentran en la carpeta database/seeds

Pasos a seguir para configurar los seeders:

    Abrir el fichero database/seeds/DatabaseSeeder.php
    En ese fichero haremos las llamadas a los seeders que queremos que ejecute:

Código de ejemplo del fichero database/seeds/DatabaseSeeder.php: 

<?php

use Illuminate\Database\Seeder;
use Illuminate\Database\Eloquent\Model;

class DatabaseSeeder extends Seeder {

	/**
	 * Run the database seeds.
	 *
	 * @return void
	 */
	public function run()
	{
		Model::unguard();

		$this->call('FabricanteSeeder');
	   	$this->call('AvionSeeder');
		// $this->call('UserTableSeeder');
	}


Creamos un fichero de Seeder para cada tabla FabricanteSeeder.php y AvionSeeder.php

php artisan make:seeder FabricanteSeeder


     Para poder configurar con qué información rellenamos las tablas necesitamos un proyecto adicional que no viene con Laravel que se llama Faker, el cuál nos permitirá generar letras, números y textos aleatorios.
    Podemos buscar ese proyecto con Composer:


    	composer search faker

    # El proyecto que nos interesa es '''fzaninotto/faker'''

    	composer require fzaninotto/faker --dev

    Documentación de Faker en: https://github.com/fzaninotto/Faker

    Ejemplo Seeder Avion:

    <?php

use Illuminate\Database\Seeder;

// Hace uso del modelo de Fabricante.
use App\Fabricante;

// Hace uso del modelo de Avion.
use App\Avion;

// Le indicamos que utilice también Faker.
// Información sobre Faker: https://github.com/fzaninotto/Faker
use Faker\Factory as Faker;

class AvionSeeder extends Seeder {

	/**
	 * Run the database seeds.
	 *
	 * @return void
	 */
	public function run()
	{
		// Creamos una instancia de Faker
		$faker = Faker::create();

		// Para cubrir los aviones tenemos que tener en cuanta qué fabricantes tenemos.
		// Para que la clave foránea no nos de problemas.
		// Averiguamos cuantos fabricantes hay en la tabla.
		$cuantos= Fabricante::all()->count();

		// Creamos un bucle para cubrir 20 aviones:
		for ($i=0; $i<19; $i++)
		{
			// Cuando llamamos al método create del Modelo Avion 
			// se está creando una nueva fila en la tabla.
			Avion::create(
				[
				 'modelo'=>$faker->word(),
				 'longitud'=>$faker->randomFloat(2,10,150),
				 'capacidad'=>$faker->randomNumber(3),	// de 3 dígitos como máximo.
				 'velocidad'=>$faker->randomNumber(4),	// de 4 dígitos como máximo.
				 'alcance'=>$faker->randomNumber(),
				 'fabricante_id'=>$faker->numberBetween(1,$cuantos)
				]
			);
		}

	}

}


Luego para correr el Faker lo que debermos de hacer, es correr el siguiente comando:


	php artisan db:seed

Si nos da algun error de Clase no encontrada (suele ocurrir al hacer los seed) entonces correremos el siguiente comando:

	composer dumpautoload

Para regresar la base de datos con el primer seeder podemos correr el siguiente comando:

	php artisan migrate:refresh --seed

     Si nos diese algún tipo de error en el require de la clase Faker haremos:

composer update fzaninotto/faker
# Se encarga de descargar el código de la clase y actualizar el fichero composer.json de nuestra aplicación.



Ahora vamos a crear los controladores para cada uno, con el siguiente comando

php artisan make:controller FabricanteController --resource
# Controller created successfully.

php artisan make:controller FabricanteAvionController --resource
# Controller created successfully.

php artisan make:controller AvionController --resource
# Controller created successfully.

# Aparecerán en la carpeta '''app/Http/Controllers''' 3 ficheros nuevos: '''FabricanteController.php''' y '''FabricanteAvionController.php''' y '''AvionController.php''' que editaremos a continuación.

------------------------------   ** Laravel Español **   --------------------------------

Antes de hacer lo de las rutas, vamos hacer un parentesis para poder pasar nuestro laravel al idioma del español, ya que estamos trabajando en ese idioma, lo que debemos hacer es lo siguiente:

Laravel Español

Paquete de traducciones en español para Laravel 5. Este paquete te agrega a tu proyecto los ficheros de traducciones en español que Laravel 5 trae por defecto.

Archivos por defecto incluidos en Laravel:

auth.php
passwords.php
pagination.php
validation.php
Instalación
Colaborar

Instalación

Puedes instalar este paquete mediante composer:

composer require laraveles/spanish
Posteriormente debes agregar el proveedor de servicios en tu fichero config/app.php:

'providers' => [
    // ...
    Laraveles\Spanish\SpanishServiceProvider::class,
];
Ahora símplemente necesitamos necesitamos actualizar las traducciones que lo haremos con el siguiente comando:

php artisan vendor:publish --tag=lang
O también podramos usar:

php artisan laraveles:install-lang
Déspues de todos estos pasos, ya tenemos disponible nuestras traducciones en español, y solo necesitamos configurar Laravel para que use el idioma deseado.

Esto lo podemos hacer modificando el parámetro locale de la configuración de Laravel en config/app.php:

// Ej: español
'locale'          => 'es',
// Ej: inglés
'locale'          => 'en',
Se puede ser mas concreto e indicar las variaciones de un lenguaje:

// Inglés americano
'locale' => 'en_US'
// Portugués de Portugal
'locale' => 'pt_PT'
Pero en este caso nos valdrá con un español internacional para todos.

También se puede cambiar el idioma en tiempo de ejecución utilizando el método setLocale de App. Este cambio no es permanente, en la siguiente ejecución se utilizará el valor de configuración por defecto:

App::setLocale('es');

------------------------------   ** FIN Laravel Español **   --------------------------------

Ahora vamos a crear las rutas, para eso fui al archivo routes/api.php

y agregamos esto:


Rutas Resource a partir de los Controladores

Otra forma de crear rutas es a partir de un Controlador es lo que se denomina una ruta Resource.

    Editaremos el fichero app/Http/routes.php eliminando su contenido actual y creando las llamadas a los recursos de controladores RESTful creados anteriormente:

<?php

/*
|--------------------------------------------------------------------------
| Application Routes
|--------------------------------------------------------------------------
|
| Here is where you can register all of the routes for an application.
| It's a breeze. Simply tell Laravel the URIs it should respond to
| and give it the controller to call when that URI is requested.
|
*/

// resource recibe nos parámetros(URI del recurso, Controlador que gestionará las peticiones)
Route::resource('fabricantes','FabricanteController');

// Como la clase principal es fabricantes y un avión no se puede crear si no le indicamos el fabricante, 
// entonces necesitaremos crear lo que se conoce como  "Recurso Anidado" de fabricantes con aviones.
// Definición del recurso anidado:
Route::resource('fabricantes.aviones','FabricanteAvionController');


La ruta aviones/create (mostraría un formulario para dar de alta un avión)
La ruta aviones/post (nos permitiría grabar ese avión)
Viendo esas dos rutas nos damos cuenta de que tenemos un error conceptual. No tenemos forma de crear un avión y pasarle al modelo el id del fabricante para que pueda establecer correctamente la clave foránea.
Un avión por si sólo no puede existir si no tenemos un fabricante que lo ha fabricado, por lo tanto la colección principal es fabricantes y necesitaremos definir lo que se conoce como recursos anidados para poder crear un avión de un fabricante.

Las rutas quedarían entonces así:


// resource recibe nos parámetros(URI del recurso, Controlador que gestionará las peticiones)
Route::resource('fabricantes','FabricanteController');

// Como la clase principal es fabricantes y un avión no se puede crear si no le indicamos el fabricante, 
// entonces necesitaremos crear lo que se conoce como  "Recurso Anidado" de fabricantes con aviones.
// Definición del recurso anidado:
Route::resource('fabricantes.aviones','FabricanteAvionController');

// Si queremos dar  la funcionalidad de ver todos los aviones tendremos que crear una ruta específica.
// Pero de aviones solamente necesitamos solamente los métodos index y show.
// Lo correcto sería hacerlo así:
Route::resource('aviones','AvionController',[ 'only'=>['index','show'] ]);


Un último detalle consistiría en eliminar el método show de fabricantes.aviones.show ya que ese método se usa para mostrar un avión y ya tenemos un aviones.show que hace esa tarea:

// resource recibe nos parámetros(URI del recurso, Controlador que gestionará las peticiones)
Route::resource('fabricantes','FabricanteController',['except'=>['edit','create'] ]);	// Todos los métodos menos Edit que mostraría un formulario de edición.

// Si queremos dar  la funcionalidad de ver todos los aviones tendremos que crear una ruta específica.
// Pero de aviones solamente necesitamos solamente los métodos index y show.
// Lo correcto sería hacerlo así:
Route::resource('aviones','AvionController',[ 'only'=>['index','show'] ]); // El resto se gestionan en FabricanteAvionController

// Como la clase principal es fabricantes y un avión no se puede crear si no le indicamos el fabricante, 
// entonces necesitaremos crear lo que se conoce como  "Recurso Anidado" de fabricantes con aviones.
// Definición del recurso anidado:
Route::resource('fabricantes.aviones','FabricanteAvionController',[ 'except'=>['show','edit','create'] ]);


Es el momento de implementar dentro de los métodos de los Controllers el código encargado de realizar las acciones correspondientes.
Códigos de estado HTTP a utilizar en la API RESTful

HTTP define un set de significativos códigos de status que pueden ser devueltos por la API. Éstos pueden ser nivelados para ayudar a los consumidores de la API dirigir sus respuestas de forma apropiada.

De forma genérica los códigos HTTP que comienzan por los números indicados abajo, tienen el siguiente significado:

    200's usados para respuestas con éxito.
    300's usados para redirecciones.
    400's usados cuando hay algún problema con la petición.
    500's usados cuando hay algún problema con el servidor.

Lista de códigos HTTP que se deberían utilizar en la API RESTful: ---

    200 OK - Respuesta a un exitoso GET, PUT, PATCH o DELETE. Puede ser usado también para un POST que no resulta en una creación.
    201 Created – [Creada] Respuesta a un POST que resulta en una creación. Debería ser combinado con un encabezado Location, apuntando a la ubicación del nuevo recurso.
    204 No Content – [Sin Contenido] Respuesta a una petición exitosa que no devuelve un body (por ejemplo en una petición DELETE)

---

    304 Not Modified – [No Modificada] Usado cuando el cacheo de encabezados HTTP está activo y el cliente puede usar datos cacheados.

---

    400 Bad Request – [Petición Errónea] La petición está malformada, como por ejemplo, si el contenido no fue bien parseado. El error se debe mostrar también en el JSON de respuesta.
    401 Unauthorized – [Desautorizada] Cuando los detalles de autenticación son inválidos o no son otorgados. También útil para disparar un popup de autorización si la API es usada desde un navegador.
    403 Forbidden – [Prohibida] Cuando la autenticación es exitosa pero el usuario no tiene permiso al recurso en cuestión.
    404 Not Found – [No encontrada] Cuando un recurso se solicita un recurso no existente.

---

    405 Method Not Allowed – [Método no permitido] Cuando un método HTTP que está siendo pedido no está permitido para el usuario autenticado.
    409 Conflict - [Conflicto] Cuando hay algún conflicto al procesar una petición, por ejemplo en PATCH, POST o DELETE.
    410 Gone – [Retirado] Indica que el recurso en ese endpoint ya no está disponible. Útil como una respuesta en blanco para viejas versiones de la API
    415 Unsupported Media Type – [Tipo de contenido no soportado] Si el tipo de contenido que solicita la petición es incorrecto
    422 Unprocessable Entity – [Entidad improcesable] Utilizada para errores de validación, o cuando por ejemplo faltan campos en una petición.
    429 Too Many Requests – [Demasiadas peticiones] Cuando una petición es rechazada debido a la tasa límite .

---

    500 – Internal Server Error – [Error Interno del servidor] Los desarrolladores de API NO deberían usar este código. En su lugar se debería loguear el fallo y no devolver respuesta.

--- Más información en: http://jsonapi.org/format/ 


Mostrar los valores de un recurso y de un recurso anidado de la API RESTful

Utilizaremos el formato JSON para devolver los datos solicitados a una URI de un recurso.

Implementación de los métodos index() y show(): 



Código de ejemplo del controlador app/Http/Controllers/FabricanteController.php: 

<?php namespace App\Http\Controllers;

use App\Http\Requests;
use App\Http\Controllers\Controller;

use Illuminate\Http\Request;

// Necesitaremos el modelo Fabricante para ciertas tareas.
use App\Fabricante;

class FabricanteController extends Controller {

	/**
	 * Display a listing of the resource.
	 *
	 * @return Response
	 */
	public function index()
	{
		// Devolverá todos los fabricantes.
		// return "Mostrando todos los fabricantes de la base de datos.";
		// return Fabricante::all();  No es lo más correcto por que se devolverían todos los registros. Se recomienda usar Filtros.
		// Se debería devolver un objeto con una propiedad como mínimo data y el array de resultados en esa propiedad.
		// A su vez también es necesario devolver el código HTTP de la respuesta.
		//php http://elbauldelprogramador.com/buenas-practicas-para-el-diseno-de-una-api-RESTful-pragmatica/
		// https://cloud.google.com/storage/docs/json_api/v1/status-codes

		return response()->json(['status'=>'ok','data'=>Fabricante::all()], 200);
	}

	/**
	 * Show the form for creating a new resource.
	 *
	 * @return Response
	 */
	public function create()
	{
		// 
		return "Se muestra formulario para crear un fabricante.";

	}

	/**
	 * Store a newly created resource in storage.
	 *
	 * @return Response
	 */
	public function store()
	{
		//
	}

	/**
	 * Display the specified resource.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function show($id)
	{
		//
		// return "Se muestra Fabricante con id: $id";
		// Buscamos un fabricante por el id.
		$fabricante=Fabricante::find($id);

		// Si no existe ese fabricante devolvemos un error.
		if (!$fabricante)
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 404.
			// En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
			return response()->json(['errors'=>array(['code'=>404,'message'=>'No se encuentra un fabricante con ese código.'])],404);
		}

		return response()->json(['status'=>'ok','data'=>$fabricante],200);

	}

	/**
	 * Show the form for editing the specified resource.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function edit($id)
	{
		//
		return "Se muestra formulario para editar Fabricante con id: $id";
	}

	/**
	 * Update the specified resource in storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function update($id)
	{
		//
	}

	/**
	 * Remove the specified resource from storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function destroy($id)
	{
		//
	}

}



Código de ejemplo del controlador app/Http/Controllers/FabricanteAvionController.php:

<?php namespace App\Http\Controllers;

use App\Http\Requests;
use App\Http\Controllers\Controller;

use Illuminate\Http\Request;

// Necesita los dos modelos Fabricante y Avion
use App\Fabricante;
use App\Avion;


class FabricanteAvionController extends Controller {

	/**
	 * Display a listing of the resource.
	 *
	 * @return Response
	 */
	public function index($idFabricante)
	{
		// Devolverá todos los aviones.
		//return "Mostrando los aviones del fabricante con Id $idFabricante";
		$fabricante=Fabricante::find($idFabricante);

		if (! $fabricante)
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 404.
			// En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
			return response()->json(['errors'=>array(['code'=>404,'message'=>'No se encuentra un fabricante con ese código.'])],404);
		}

		return response()->json(['status'=>'ok','data'=>$fabricante->aviones()->get()],200);
		//return response()->json(['status'=>'ok','data'=>$fabricante->aviones],200);
	}

	/**
	 * Show the form for creating a new resource.
	 *
	 * @return Response
	 */
	public function create($idFabricante)
	{
		//
		return "Se muestra formulario para crear un avión del fabricante $idFabricante.";
	}

	/**
	 * Store a newly created resource in storage.
	 *
	 * @return Response
	 */
	public function store()
	{
		//
	}

	/**
	 * Display the specified resource.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function show($idFabricante,$idAvion)
	{
		//
		return "Se muestra avión $idAvion del fabricante $idFabricante";
	}

	/**
	 * Show the form for editing the specified resource.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function edit($idFabricante,$idAvion)
	{
		//
		return "Se muestra formulario para editar el avión $idAvion del fabricante $idFabricante";
	}

	/**
	 * Update the specified resource in storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function update($idFabricante,$idAvion)
	{
		//
	}

	/**
	 * Remove the specified resource from storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function destroy($idFabricante,$idAvion)
	{
		//
	}

}




Los middlewares en Laravel 5

Los middleware HTTP proporcionan un mecanismo de filtrado de peticiones HTTP que acceden a nuestra aplicación. Por ejemplo Laravel incluye un middleware que verifica si el usuario de nuestra aplicación está autenticado. Si el usuario no está autenticado, el middleware redirecciona al usuario a una página de autenticación. Si el usuario está autenticado, el middleware permitirá acceder al recurso solicitado en la aplicación.

En el framework Laravel se incluyen muchos middlewares como por ejemplo para mantenimiento, autenticación, protección CSRF, etc.

Todos los middleware se localizan en la carpeta app/Http/Middleware.

Para generar una plantilla de middleware se puede hacer con PHP Artisan:

php artisan make:middleware NombreMiddleware

En el fichero app/Http/Kernel.php se definen los middlewares que se cargarán al inicio de nuestra aplicación.

<?php namespace App\Http;

use Illuminate\Foundation\Http\Kernel as HttpKernel;

class Kernel extends HttpKernel {

	/**
	 * The application's global HTTP middleware stack.
	 *
	 * @var array
	 */
	// Aquí se programa el Middleware que se cargará siempre y globalmente en la aplicación.
	protected $middleware = [
		'Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode',
		'Illuminate\Cookie\Middleware\EncryptCookies',
		'Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse',
		'Illuminate\Session\Middleware\StartSession',
		'Illuminate\View\Middleware\ShareErrorsFromSession',
		'App\Http\Middleware\VerifyCsrfToken', --> Es este!
	];

	/**
	 * The application's route middleware.
	 *
	 * @var array
	 */

	// Aquí se programa el Middleware que se cargará dependiendo de la ruta.
	protected $routeMiddleware = [
		'auth' => 'App\Http\Middleware\Authenticate',
		'auth.basic' => 'Illuminate\Auth\Middleware\AuthenticateWithBasicAuth',
		'guest' => 'App\Http\Middleware\RedirectIfAuthenticated',
	];

}


Ahora lo que vamos  hacer en el Modelo de Users hace mos los siguientes cambios:


class User extends Model implements AuthenticatableContract, CanResetPasswordContract {

	use Authenticatable, CanResetPassword;

	/**
	 * The database table used by the model.
	 *
	 * @var string
	 */
	protected $table = 'users';

	/**
	 * The attributes that are mass assignable.
	 *
	 * @var array
	 */

	// ELiminamos el campo name, nos vamos a autenticar solamente con email y password. --> Removemos name
	protected $fillable = ['email', 'password'];

	/**
	 * The attributes excluded from the model's JSON form.
	 *
	 * @var array
	 */

	// Eliminamos el campo remember_token --> Removemos remember_token
	protected $hidden = ['password'];

} 



Tambien vamos a modificar la migracion de users:

<?php

use Illuminate\Database\Schema\Blueprint;
use Illuminate\Database\Migrations\Migration;

class Users extends Migration {

	/**
	 * Run the migrations.
	 *
	 * @return void
	 */
	public function up()
	{
		Schema::create('users', function(Blueprint $table)
		{
			$table->increments('id');
			$table->string('email')->unique();
			$table->string('password');
			$table->timestamps();
		});
	}

	/**
	 * Reverse the migrations.
	 *
	 * @return void
	 */
	public function down()
	{
		Schema::drop('users');
	}

}




Ahora creamos un seeder para user y solo vamos 

php artisan make:seeder UserSeeder

y luego ejecutamos
	//Para refrescar
	composer dump-autoload

y luego:
	//ejecutamos los seeders
	php artisan db:seed

# Si queremos dejar la base de datos en su estado inicial y que ejecute 1 seed haremos:
php artisan migrate:refresh --seed


Al intentar correr el comando anterior medio el siguiente problema:
	Generating optimized autoload files
> Illuminate\Foundation\ComposerScripts::postAutoloadDump
> @php artisan package:discover


y trataba de correr composer dumpautoload y me daba otro error, para arreglarlo tuve que hacer lo siguiente:

This is because of your Laravel Installer or Composer version. I have faced the same problem and found following 2 different solutions:

Generally you can solve with by running composer global update command and then run composer update command from your project directory. This solution basically updates your installer and then your project.

If still, you have this issue, you need to run composer self-update command first and then run composer update command from your project directory. Here your composer will update and then your project.

Hope this information will help you.

Lo que hice fue correr:
	
	composer self-update

y ya despues pude correr 

	composer dumpautoload



pero cuando volvi a intentar migration:refresh, me dio error de nuevo, entonces parece que lo que da error es que en el archivo DatabaseSeeder.php yo tengo la siguiente funcion User::truncate(); en donde lo que hice fue agregar el siguiente use App\User; en el archivo DatabaseSeeder.php

Despues de eso ya me corrio y se me soluciono el problema

y luego
	 php artisan migrate:refresh --seed


Ahora se agregaron los middlware a cada modelo, bueno al de Fabricante y FabricanteAvion, ejemplo:

<?php

namespace App\Http\Controllers;
//Se necesitan los 2 modelos
use App\Avion;
use App\Fabricante;
use Illuminate\Http\Request;

class FabricanteAvionController extends Controller
{

    // Configuramos en el constructor del controlador la autenticación usando el Middleware auth.basic,
    // pero solamente para los métodos de crear, actualizar y borrar.

    public function __construct()
    {
        $this->middleware('auth.basic', ['only'=>['store', 'update', 'destroy']]);
    }

    /**
     * Display a listing of the resource.
     *
     * @return \Illuminate\Http\Response
     */
    //Ojo que recibe un id_fabricante
    public function index($id_fabricante)
    {
        // Devolverá todos los aviones.
        //return "Mostrando los aviones del fabricante con Id $idFabricante";
        $fabricante = Fabricante::find($id_fabricante);

        if(!fabricante){
            // Se devuelve un array errors con los errores encontrados y cabecera HTTP 404.
            // En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
            return response()->json(['errors'=>array(['code'=>'404','message'=>'No se encontro ningun fabricante con ese codigo']),404]);
        }
        return response()->json(['status'=>'ok', 'data'=>$fabricante->aviones()->get()],200);
    }

    /**
     * Show the form for creating a new resource.
     *
     * @return \Illuminate\Http\Response
     */
    public function create($id_fabricante)
    {
        //
        return "Se muestra formulario para crear un avion del fabricante $id_fabricante";
    }

    /**
     * Store a newly created resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        //
    }

    /**
     * Display the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function show($id_fabricante, $id_avion)
    {
        //
        return "Se muestra avion $id_avion del fabricante $id_fabricante";
    }

    /**
     * Show the form for editing the specified resource.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function edit($id_fabricante, $id_avion)
    {
        //
        return "Se muestra formulario para editar el avion $id_avion del fabricante $id_fabricante";
    }

    /**
     * Update the specified resource in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function update(Request $request, $id)
    {
        //
    }

    /**
     * Remove the specified resource from storage.
     *
     * @param  int  $id
     * @return \Illuminate\Http\Response
     */
    public function destroy($idFabricante, $idAvion)
    {
        //
    }
}



AHORA, Editaremos el fichero del controlador app/Http/Controllers/FabricanteController.php:


<?php namespace App\Http\Controllers;

use App\Http\Requests;
use App\Http\Controllers\Controller;

use Illuminate\Http\Request;

// Necesitaremos el modelo Fabricante para ciertas tareas.
use App\Fabricante;

// Necesitamos la clase Response para crear la respuesta especial con la cabecera de localización en el método Store()
use Response;

class FabricanteController extends Controller {

	// Configuramos en el constructor del controlador la autenticación usando el Middleware auth.basic,
	// pero solamente para los métodos de crear, actualizar y borrar.
	public function __construct()
	{
		$this->middleware('auth.basic',['only'=>['store','update','destroy']]);
	}

	/**
	 * Display a listing of the resource.
	 *
	 * @return Response
	 */
	public function index()
	{
		// Devolverá todos los fabricantes.
		// return "Mostrando todos los fabricantes de la base de datos.";
		// return Fabricante::all();  No es lo más correcto por que se devolverían todos los registros. Se recomienda usar Filtros.
		// Se debería devolver un objeto con una propiedad como mínimo data y el array de resultados en esa propiedad.
		// A su vez también es necesario devolver el código HTTP de la respuesta.
		//php http://elbauldelprogramador.com/buenas-practicas-para-el-diseno-de-una-api-RESTful-pragmatica/
		// https://cloud.google.com/storage/docs/json_api/v1/status-codes

		return response()->json(['status'=>'ok','data'=>Fabricante::all()], 200);
	}


	/**
	 * Store a newly created resource in storage.
	 *
	 * @return Response
	 */

	// Pasamos como parámetro al método store todas las variables recibidas de tipo Request
	// utilizando inyección de dependencias (nuevo en Laravel 5)
	// Para acceder a Request necesitamos asegurarnos que está cargado use Illuminate\Http\Request;
	// Información sobre Request en: http://laravel.com/docs/5.0/requests 
	// Ejemplo de uso de Request:  $request->input('name');
	public function store(Request $request)
	{

		// Primero comprobaremos si estamos recibiendo todos los campos.
		if (!$request->input('nombre') || !$request->input('direccion') || !$request->input('telefono'))
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 422 Unprocessable Entity – [Entidad improcesable] Utilizada para errores de validación.
			// En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
			return response()->json(['errors'=>array(['code'=>422,'message'=>'Faltan datos necesarios para el proceso de alta.'])],422);
		}

		// Insertamos una fila en Fabricante con create pasándole todos los datos recibidos.
		// En $request->all() tendremos todos los campos del formulario recibidos.
		$nuevoFabricante=Fabricante::create($request->all());

		// Más información sobre respuestas en http://jsonapi.org/format/
		// Devolvemos el código HTTP 201 Created – [Creada] Respuesta a un POST que resulta en una creación. Debería ser combinado con un encabezado Location, apuntando a la ubicación del nuevo recurso.
		$response = Response::make(json_encode(['data'=>$nuevoFabricante]), 201)->header('Location', 'http://www.dominio.local/fabricantes/'.$nuevoFabricante->id)->header('Content-Type', 'application/json');
		return $response;
	}

	/**
	 * Display the specified resource.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function show($id)
	{
		//
		// return "Se muestra Fabricante con id: $id";
		// Buscamos un fabricante por el id.
		$fabricante=Fabricante::find($id);

		// Si no existe ese fabricante devolvemos un error.
		if (!$fabricante)
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 404.
			// En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
			return response()->json(['errors'=>array(['code'=>404,'message'=>'No se encuentra un fabricante con ese código.'])],404);
		}

		return response()->json(['status'=>'ok','data'=>$fabricante],200);

	}



	/**
	 * Update the specified resource in storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function update($id)
	{
		//
	}

	/**
	 * Remove the specified resource from storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function destroy($id)
	{
		//
	}

}



Editaremos el fichero del controlador app/Http/Controllers/FabricanteAvionController.php:


<?php namespace App\Http\Controllers;

use App\Http\Requests;
use App\Http\Controllers\Controller;

use Illuminate\Http\Request;

// Necesita los dos modelos Fabricante y Avion
use App\Fabricante;
use App\Avion;

// Necesitamos la clase Response para crear la respuesta especial con la cabecera de localización en el método Store()
use Response;


class FabricanteAvionController extends Controller {
	// Configuramos en el constructor del controlador la autenticación usando el Middleware auth.basic,
	// pero solamente para los métodos de crear, actualizar y borrar.
	public function __construct()
	{
		$this->middleware('auth.basic',['only'=>['store','update','destroy']]);
	}

	/**
	 * Display a listing of the resource.
	 *
	 * @return Response
	 */
	public function index($idFabricante)
	{
		// Devolverá todos los aviones.
		//return "Mostrando los aviones del fabricante con Id $idFabricante";
		$fabricante=Fabricante::find($idFabricante);

		if (! $fabricante)
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 404.
			// En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
			return response()->json(['errors'=>array(['code'=>404,'message'=>'No se encuentra un fabricante con ese código.'])],404);
		}

		return response()->json(['status'=>'ok','data'=>$fabricante->aviones()->get()],200);
		//return response()->json(['status'=>'ok','data'=>$fabricante->aviones],200);
	}


	/**
	 * Store a newly created resource in storage.
	 *
	 * @return Response
	 */
	public function store(Request $request,$idFabricante)
	{
		/* Necesitaremos el fabricante_id que lo recibimos en la ruta
		 #Serie (auto incremental)
		Modelo
		Longitud
		Capacidad
		Velocidad
		Alcance */

		// Primero comprobaremos si estamos recibiendo todos los campos.
		if ( !$request->input('modelo') || !$request->input('longitud') || !$request->input('capacidad') || !$request->input('velocidad') || !$request->input('alcance') )
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 422 Unprocessable Entity – [Entidad improcesable] Utilizada para errores de validación.
			return response()->json(['errors'=>array(['code'=>422,'message'=>'Faltan datos necesarios para el proceso de alta.'])],422);
		}

		// Buscamos el Fabricante.
		$fabricante= Fabricante::find($idFabricante);

		// Si no existe el fabricante que le hemos pasado mostramos otro código de error de no encontrado.
		if (!$fabricante)
		{
			// Se devuelve un array errors con los errores encontrados y cabecera HTTP 404.
			// En code podríamos indicar un código de error personalizado de nuestra aplicación si lo deseamos.
			return response()->json(['errors'=>array(['code'=>404,'message'=>'No se encuentra un fabricante con ese código.'])],404);
		}

		// Si el fabricante existe entonces lo almacenamos.
		// Insertamos una fila en Aviones con create pasándole todos los datos recibidos.
		$nuevoAvion=$fabricante->aviones()->create($request->all());

		// Más información sobre respuestas en http://jsonapi.org/format/
		// Devolvemos el código HTTP 201 Created – [Creada] Respuesta a un POST que resulta en una creación. Debería ser combinado con un encabezado Location, apuntando a la ubicación del nuevo recurso.
		$response = Response::make(json_encode(['data'=>$nuevoAvion]), 201)->header('Location', 'http://www.dominio.local/aviones/'.$nuevoAvion->serie)->header('Content-Type', 'application/json');
		return $response;
	}

	/**
	 * Display the specified resource.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function show($idFabricante,$idAvion)
	{
		//
		return "Se muestra avión $idAvion del fabricante $idFabricante";
	}

	/**
	 * Update the specified resource in storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function update($idFabricante,$idAvion)
	{
		//
	}

	/**
	 * Remove the specified resource from storage.
	 *
	 * @param  int  $id
	 * @return Response
	 */
	public function destroy($idFabricante,$idAvion)
	{
		//
	}

}











